use std::fmt::Debug;

use thiserror::Error;
use uom::si::f64::Time;

use crate::Component;

use super::{Controller, Integrator, Temporal, TimeStep};

/// A simulation engine that models the time evolution of a [`Component`].
///
/// `Simulation` manages the progression of a component through simulated
/// time by maintaining a history of [`TimeStep`]s.
/// Each time step records an input and its corresponding output, capturing the
/// state of the system at a specific time.
///
/// The simulation is advanced using an [`Integrator`], which produces the next
/// input based on the current history and a time increment.
/// Optionally, a [`Controller`] may be used to adjust the integrated input
/// before it is evaluated by the component.
pub struct Simulation<C>
where
    C: Component,
    C::Input: Clone + Debug + Temporal,
    C::Output: Clone + Debug,
{
    component: C,
    history: Vec<TimeStep<C>>,
}

/// Errors that can occur when advancing a [`Simulation`] without a controller.
///
/// This enum covers failures from either the component or the integrator:
///
/// - [`Component`]: The component failed when called on the new input.
/// - [`Integrator`]: The integrator failed to generate the next input.
#[derive(Debug, Error)]
pub enum StepError<C, I>
where
    C: Component,
    C::Input: Clone + Debug + Temporal,
    C::Output: Clone + Debug,
    I: Integrator<C>,
{
    #[error("Component failed: {0}")]
    Component(C::Error),

    #[error("Integrator failed: {0}")]
    Integrator(I::Error),
}

/// Errors that can occur when advancing a [`Simulation`] using a controller.
///
/// This enum covers failures from the component, the integrator, or the
/// controller:
///
/// - [`Integrator`]: Failed to generate an input candidate.
/// - [`Controller`]: Failed to adjust the input candidate.
/// - [`Component`]: Failed when called on the adjusted input.
#[derive(Debug, Error)]
pub enum StepWithControllerError<C, I, K>
where
    C: Component,
    C::Input: Clone + Debug + Temporal,
    C::Output: Clone + Debug,
    I: Integrator<C>,
    K: Controller<C>,
{
    #[error("Component failed: {0}")]
    Component(C::Error),

    #[error("Controller failed: {0}")]
    Controller(K::Error),

    #[error("Integrator failed: {0}")]
    Integrator(I::Error),
}

impl<C> Simulation<C>
where
    C: Component,
    C::Input: Clone + Debug + Temporal,
    C::Output: Clone + Debug,
{
    /// Creates a new [`Simulation`] from a component and its initial input.
    ///
    /// The simulation starts with a single [`TimeStep`], generated by
    /// evaluating the component at the provided input.
    /// This step is recorded as the first entry in the simulation history.
    ///
    /// # Parameters
    ///
    /// - `component`: The component to simulate.
    /// - `initial_input`: The input at the starting point of the simulation.
    ///
    /// # Returns
    ///
    /// A new [`Simulation`] instance initialized with one recorded time step.
    ///
    /// # Errors
    ///
    /// Returns `Err(C::Error)` if the component fails when called on the
    /// initial input.
    pub fn new(component: C, initial_input: C::Input) -> Result<Self, C::Error> {
        let initial_output = component.call(initial_input.clone())?;
        Ok(Self {
            component,
            history: vec![TimeStep {
                input: initial_input,
                output: initial_output,
            }],
        })
    }

    /// Advances the simulation forward by one time step without a controller.
    ///
    /// This method uses the given [`Integrator`] to produce the next input
    /// based on the current simulation history and time increment `dt`.
    /// It then evaluates the component at that input to produce a new output,
    /// and records the resulting [`TimeStep`] in the simulation history.
    ///
    /// # Parameters
    ///
    /// - `integrator`: The integrator used to advance the simulation.
    /// - `dt`: The time increment for this step.
    ///
    /// # Returns
    ///
    /// A reference to the newly recorded [`TimeStep`] at the end of the
    /// simulation history.
    ///
    /// # Errors
    ///
    /// Returns a [`StepError`] if either the integrator fails to generate a new
    /// input, or the component fails when evaluated at that input.
    #[allow(clippy::missing_panics_doc)]
    pub fn step<I>(&mut self, integrator: &I, dt: Time) -> Result<&TimeStep<C>, StepError<C, I>>
    where
        I: Integrator<C>,
    {
        let input = integrator
            .propose_input(&self.component, &self.history, dt)
            .map_err(StepError::Integrator)?;

        let output = self
            .component
            .call(input.clone())
            .map_err(StepError::Component)?;

        self.history.push(TimeStep { input, output });

        Ok(self
            .history
            .last()
            .expect("History cannot be empty after pushing"))
    }

    /// Advances the simulation forward by one time step using a controller.
    ///
    /// This method first uses the given [`Integrator`] to propose the next
    /// input based on the simulation history and time increment `dt`.
    /// The proposed input is then passed to the [`Controller`], which may
    /// adjust it based on custom logic or constraints derived from the
    /// simulation history.
    /// The finalized input is evaluated by the component, and the resulting
    /// [`TimeStep`] is recorded in the simulation history.
    ///
    /// # Parameters
    ///
    /// - `integrator`: The integrator used to propose the next input.
    /// - `controller`: The controller used to adjust the proposed input.
    /// - `dt`: The time increment for this step.
    ///
    /// # Returns
    ///
    /// A reference to the newly recorded [`TimeStep`] at the end of the
    /// simulation history.
    ///
    /// # Errors
    ///
    /// Returns a [`StepWithControllerError`] if the integrator fails to propose
    /// an input, the controller fails to adjust it, or the component fails when
    /// evaluated at it.
    #[allow(clippy::missing_panics_doc)]
    pub fn step_with_controller<I, K>(
        &mut self,
        integrator: &I,
        controller: &K,
        dt: Time,
    ) -> Result<&TimeStep<C>, StepWithControllerError<C, I, K>>
    where
        I: Integrator<C>,
        K: Controller<C>,
    {
        let trial_input = integrator
            .propose_input(&self.component, &self.history, dt)
            .map_err(StepWithControllerError::Integrator)?;

        let input = controller
            .adjust_input(&self.component, &self.history, trial_input)
            .map_err(StepWithControllerError::Controller)?;

        let output = self
            .component
            .call(input.clone())
            .map_err(StepWithControllerError::Component)?;

        self.history.push(TimeStep { input, output });

        Ok(self
            .history
            .last()
            .expect("History cannot be empty after pushing"))
    }

    /// Returns the simulation time of the most recent step.
    #[allow(clippy::missing_panics_doc)]
    pub fn current_time(&self) -> Time {
        self.history
            .last()
            .expect("Simulation history is never empty")
            .input
            .get_time()
    }

    /// Returns the full history of simulation steps.
    ///
    /// The history is a slice of [`TimeStep`]s, each containing the input and
    /// output of the component at a specific point in simulated time.
    /// The first entry corresponds to the initial input provided when the
    /// simulation was created.
    pub fn history(&self) -> &[TimeStep<C>] {
        &self.history
    }

    /// Returns an iterator over all recorded [`TimeStep`]s in the simulation.
    pub fn iter_history(&self) -> impl Iterator<Item = &TimeStep<C>> {
        self.history.iter()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    use uom::si::{
        f64::{Length, Time, Velocity},
        length::meter,
        time::second,
        velocity::meter_per_second,
    };

    use crate::transient::integrators::ForwardEuler;
    use crate::transient::test_utils::{MovingPoint, PointInput};

    #[test]
    fn moving_point_moves_as_expected() {
        let mut sim = Simulation::new(
            // A moving point with constant velocity of 3 m/s.
            MovingPoint::new(Velocity::new::<meter_per_second>(3.0)),
            // Initial conditions are position = 0 m, time = 0 s.
            PointInput::default(),
        )
        .unwrap();
        assert_eq!(sim.history().len(), 1);

        // Step forward by 1 second using forward Euler.
        sim.step(&ForwardEuler, Time::new::<second>(1.0)).unwrap();
        assert_eq!(sim.history().len(), 2);

        // Then step forward by 4 more seconds using forward Euler.
        sim.step(&ForwardEuler, Time::new::<second>(4.0)).unwrap();
        assert_eq!(sim.history().len(), 3);

        // Collect simulation timestamps and positions.
        let times: Vec<_> = sim.iter_history().map(|step| step.input.time).collect();
        let positions: Vec<_> = sim
            .history()
            .iter()
            .map(|step| step.input.position)
            .collect();

        assert_eq!(
            times,
            vec![
                Time::new::<second>(0.0),
                Time::new::<second>(1.0),
                Time::new::<second>(5.0),
            ]
        );

        assert_eq!(
            positions,
            vec![
                Length::new::<meter>(0.0),
                Length::new::<meter>(3.0),
                Length::new::<meter>(15.0),
            ]
        );
    }
}
